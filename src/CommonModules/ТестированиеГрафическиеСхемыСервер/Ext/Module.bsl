
#Область РасщиряемыеМетоды

&ИзменениеИКонтроль("ГрафическаяСхемаПоДеревуСхемы")
Функция ГрафическаяСхема_2_0_1_48_ГрафическаяСхемаПоДеревуСхемы(ДеревоСхемы)
	Схема                = Новый ГрафическаяСхема;
	ГрафическаяСхемаXDTO = ГрафическаяСхемаXDTO(Схема);

	МатрицаЭлементов = МатрицаЭлементовПоДеревуСхемы(ГрафическаяСхемаXDTO,ДеревоСхемы);
	#Вставка
	ПреобразоватьМатрицуЭлементовПоШирине(МатрицаЭлементов, МаксимальноеКоличествоЭлементовПоШирине());
	#КонецВставки

	ПреобразоватьМатрицуВОбъектГрафическаяСхемаXDTO(ГрафическаяСхемаXDTO,МатрицаЭлементов,ДеревоСхемы);

	СтруктураВозврата = СхемаИзСпискаXDTO(ГрафическаяСхемаXDTO);
	СтруктураВозврата.Вставить("МатрицаЭлементов",МатрицаЭлементов);

	Возврат СтруктураВозврата;
КонецФункции

&ИзменениеИКонтроль("СоединитьФигуры")
Процедура ГрафическаяСхема_2_0_1_48_СоединитьФигуры(ГрафическаяСхемаXDTO, ЭлементСхемы1, ЭлементСхемы2, ТипСоединения, ВидСоединения)
	Стрелка = ФигураСоединениеПоТипуУправления(ГрафическаяСхемаXDTO,ТипСоединения);

	СвойстваСоединения        = СоединениеЭлементов(ЭлементСхемы1,ЭлементСхемы2,ВидСоединения);

	Стрелка.connectFromItemId = ЭлементСхемы1.ItemID;
	Стрелка.connectToItemId   = ЭлементСхемы2.ItemID;
	Стрелка.portIndexFrom     = СвойстваСоединения.portIndexFrom; 
	Стрелка.portIndexTo       = СвойстваСоединения.portIndexTo;

	//обычное соединение
	//надо явно указать координаты стрелки
	Стрелка.point[0].x = СвойстваСоединения.pointFrom.x;
	Стрелка.point[0].y = СвойстваСоединения.pointFrom.y;
	Стрелка.point[3].x = СвойстваСоединения.pointTo.x;
	Стрелка.point[3].y = СвойстваСоединения.pointTo.y;

	Если ВидСоединения = "УсловиеВеткаFalse" Тогда
		Если ЭлементСхемы1.RectTop >= ЭлементСхемы2.RectTop Тогда
			//они в одном ряду
			Стрелка.point[1].x = Стрелка.point[0].x;
			Стрелка.point[1].y = Стрелка.point[0].y + 20;

			Стрелка.point[2].x = Стрелка.point[3].x;
			Стрелка.point[2].y = Стрелка.point[0].y + 20;
		Иначе	
			Стрелка.point.Удалить(1);

			Стрелка.point[1].x = Стрелка.point[0].x;
			Стрелка.point[1].y = Стрелка.point[2].y;
		КонецЕсли;	 
	ИначеЕсли (ЭтоЭлементСтоп(ЭлементСхемы2)) И (ЭлементСхемы1.RectTop > ЭлементСхемы2.RectTop) Тогда
		Стрелка.point.Удалить(1);
		Стрелка.point[1].x = Стрелка.point[2].x;
		Стрелка.point[1].y = Стрелка.point[0].y;
	Иначе	
		Если (ЭлементСхемы1.RectTop > ЭлементСхемы2.RectTop) Тогда
			//надо сделать соединение снизу
			Если ЭлементСхемы1.RectLeft = ЭлементСхемы2.RectLeft Тогда
				Стрелка.point.Удалить(1);
				Стрелка.point[1].x = Стрелка.point[2].x;
				Стрелка.point[1].y = Стрелка.point[0].y;
			ИначеЕсли ЭлементСхемы1.RectLeft < ЭлементСхемы2.RectLeft Тогда
				Стрелка.point.Удалить(1);
				Стрелка.point[1].x = Стрелка.point[2].x;
				Стрелка.point[1].y = Стрелка.point[0].y;
			Иначе	
				Стрелка.point[1].x = Стрелка.point[0].x;
				Стрелка.point[1].y = Стрелка.point[0].y - 20;

				//второй поворот стрелки
				Стрелка.point[2].x = Стрелка.point[3].x;
				Стрелка.point[2].y = Стрелка.point[1].y;
			КонецЕсли;	 
		Иначе	
			//первый поворот стрелки
			#Удаление
			Стрелка.point[1].x = Стрелка.point[0].x + Окр((Стрелка.point[3].x - Стрелка.point[0].x)/2);
			Стрелка.point[1].y = Стрелка.point[0].y;

			//второй поворот стрелки
			Стрелка.point[2].x = Стрелка.point[1].x;
			Стрелка.point[2].y = Стрелка.point[3].y;
			#КонецУдаления
			#Вставка
			Если Стрелка.point[0].y = Стрелка.point[3].y Тогда
				Стрелка.point.Удалить(1);
				Стрелка.point.Удалить(1);
			Иначе
				Стрелка.point[1].x = Стрелка.point[0].x;
				Стрелка.point[1].y = Стрелка.point[0].y + Окр((Стрелка.point[3].y - Стрелка.point[0].y)/2);
				//второй поворот стрелки
				Стрелка.point[2].x = Стрелка.point[3].x;
				Стрелка.point[2].y = Стрелка.point[0].y + Окр((Стрелка.point[3].y - Стрелка.point[0].y)/2);
			КонецЕсли;
			#КонецВставки
		КонецЕсли;	 

	КонецЕсли;	 

	Если ВидСоединения = "УсловиеВеткаFalse" Тогда
		Стрелка.itemTitle.item[0].content = "Нет";
	ИначеЕсли ВидСоединения = "УсловиеВеткаTrue" Тогда
		Стрелка.itemTitle.item[0].content = "Да";
	КонецЕсли;	 

	ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(Стрелка);
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ПреобразоватьМатрицуЭлементовПоШирине(МатрицаЭлементов, МаксимальнаяШирина)
	
	КоличествоКолонок = МатрицаЭлементов.Колонки.Количество();
	Если НЕ ТребуетсяПреобразование(КоличествоКолонок, МаксимальнаяШирина) Тогда
		Возврат;
	КонецЕсли;
	КоличествоСтрок = МатрицаЭлементов.Количество();
	
	ТекущаяСтрока = 0;
	// Обходим исходные строки матрицы элементов.
	Пока ТекущаяСтрока < КоличествоСтрок Цикл
		ИндексДобавленнойСтроки = ТекущаяСтрока + 1;
		ИндексСледующейСтроки = ТекущаяСтрока + 2;
		ИндексДобавленнойКолонки = 0;
		МатрицаЭлементов.Вставить(ИндексДобавленнойСтроки);
		КоличествоСтрок = КоличествоСтрок + 1;
		// Переносим элементы из столбцов, превышающих максимальную ширину
		// в новые строки, добавляемые ниже текущей строки
		Для ТекущаяКолонка = МаксимальнаяШирина По КоличествоКолонок - 1 Цикл
			Элемент = МатрицаЭлементов[ТекущаяСтрока][ТекущаяКолонка];
			// Количество столбцов может потребовать перенос на несколько новых строк.
			Если ИндексДобавленнойКолонки = МаксимальнаяШирина Тогда
				ИндексДобавленнойКолонки = 0;
				ИндексДобавленнойСтроки = ИндексДобавленнойСтроки + 1;
				МатрицаЭлементов.Вставить(ИндексДобавленнойСтроки);
				КоличествоСтрок = КоличествоСтрок + 1;
				ИндексСледующейСтроки = ИндексСледующейСтроки + 1;
			КонецЕсли;
			МатрицаЭлементов[ИндексДобавленнойСтроки][ИндексДобавленнойКолонки] = Элемент;
			ИндексДобавленнойКолонки = ИндексДобавленнойКолонки + 1;
		КонецЦикла;
		ТекущаяСтрока = ИндексСледующейСтроки;
	КонецЦикла;
	
	// Удаление столбцов матрицы, из которых перенесли элементы.
	КоличествоКолонокКУдалению = КоличествоКолонок - МаксимальнаяШирина;
	УдалитьПоследниеКолонкиТаблицыЗначений(МатрицаЭлементов.Колонки, КоличествоКолонокКУдалению);
	
КонецПроцедуры

Функция ТребуетсяПреобразование(КоличествоКолонок, МаксимальнаяШирина)
	
	Возврат КоличествоКолонок > МаксимальнаяШирина;
	
КонецФункции

Процедура УдалитьПоследниеКолонкиТаблицыЗначений(Колонки, КоличествоКолонокКУдалению)
	
	КоличествоКолонок = Колонки.Количество();
	Для Счетчик = 1 По КоличествоКолонокКУдалению Цикл
		Колонки.Удалить(КоличествоКолонок - Счетчик);
	КонецЦикла;
	
КонецПроцедуры

Функция МаксимальноеКоличествоЭлементовПоШирине()
	Возврат 4;
КонецФункции

#КонецОбласти
